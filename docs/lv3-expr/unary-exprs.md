# Lv3.1. 一元表达式

因为本章开头的语法规范里突然多出一大堆产生式, 所以你可能会觉得有些手足无措. 那我们不如把这对新加的内容在做一些拆分, 先来实现一元表达式的部分.

本节新增/变更的语法规范如下:

```ebnf
Stmt        ::= "return" Exp ";";

Exp         ::= UnaryExp;
PrimaryExp  ::= "(" Exp ")" | Number;
Number      ::= INT_CONST;
UnaryExp    ::= PrimaryExp | UnaryOp UnaryExp;
UnaryOp     ::= "+" | "-" | "!";
```

你需要让你的编译器支持 `+`, `-` 和 `!` 运算, 同时支持括号表达式.

## 一个例子

```c
int main() {
  return +(- -!6);  // 看起来像个颜文字
}
```

## 词法/语法分析

本节新增了三个运算符: `+`, `-` 和 `!`. 对于 C/C++ 实现, 你可以对 Flex 部分稍作修改, 使其对这些运算符进行特殊处理. 但你应该还记得, Lv1 中, 我们添加了可以匹配任意单个字符的规则. 因为新增的三个运算符刚好各自只有一个字符, 所以这个规则也可以用来匹配这些新增内容, 所以你不对 Flex 部分作修改也是可以的.

语法分析部分, 你需要根据语法规则, 设计一些新的 AST. 也许你需要回顾一下 Lv1 中关于如何设计 AST 的[相关部分](/lv1-main/parsing-main?id=设计-ast). 然后修改你的语法分析器, 使其支持根据新增的语法规则生成对应的 AST.

需要注意的是, 目前的 EBNF 中出现了一些包含 `|` 的规则, 比如:

```ebnf
PrimaryExp  ::= "(" Exp ")" | Number;
UnaryExp    ::= PrimaryExp | UnaryOp UnaryExp;
```

对于这种情况, 设计 AST 时, 你可以采取很多种处理方式, 比如:

* 对 `::=` 右侧的每个规则都设计一种 AST, 在 parse 到对应规则时, 构造对应的 AST.
* 或者, 只为 `::=` 左侧的符号设计一种 AST, 使其涵盖 `::=` 右侧的所有规则. 比如在 Rust 中, 你可以用 `enum` 来表达这种行为.

实现语法分析器时, 你需要使用语法分析器支持的语法实现 `|`, 详情请自行 RTFM 或 STFW.

## 语义分析

暂无需要添加的内容.

## IR 生成

查询 [Koopa IR 规范](/misc-app-ref/koopa), 你会发现, Koopa IR 并不支持一元运算, 而只支持如下的二元运算:

* **比较运算:** `ne` (比较不等), `eq` (比较相等), `gt` (比较大于), `lt` (比较小于), `ge` (比较大于等于), `le` (比较小于等于). 返回整数形式的真 (非 0) 或假 (0).
* **算术运算:** `add` (加法), `sub` (减法), `mul` (乘法), `div` (除法), `mod` (模运算).
* **位运算:** `and` (按位与), `or` (按位或), `xor` (按位异或).
* **移位:** `shl` (左移), `shr` (逻辑右移), `sar` (算术右移).

这是因为, 目前已知有意义的一元操作均可用二元操作表示:

* **变补 (取负数)**: 0 减去操作数.
* **按位取反**: 操作数异或全 1 (即 `-1`).
* **逻辑取反**: 操作数和 0 比较相等.

所以, 示例代码可以生成如下的 Koopa IR:

```koopa
fun @main(): i32 {
%entry:
  %0 = eq 6, 0
  %1 = sub 0, %0
  %2 = sub 0, %1
  ret %2
}
```

你需要注意的是:

* `+` 运算实际上不会生成任何 IR.
* Koopa IR 中, `%` 后可以跟任意正整数, 同样表示临时符号.
* Koopa IR 是 “单赋值” 的, 即: 所有符号都只能在定义的时候被赋值一次, 所以你必须保证函数内所有的符号 (包括指令和基本块) 都具备不同的名称. 如下的 IR 程序是不合法的:

```koopa
fun @main(): i32 {
%entry:
  %0 = eq 6, 0
  // 不能重复定义符号
  %0 = sub 0, %0
  ret %0
}
```

## 目标代码生成

对于由示例代码生成的 Koopa IR:

```koopa
fun @main(): i32 {
%entry:
  %0 = eq 6, 0
  %1 = sub 0, %0
  %2 = sub 0, %1
  ret %2
}
```

可以进一步生成如下的 RISC-V 汇编:

```
  .text
  .globl main
main:
  # 实现 eq 6, 0 的操作, 并把结果存入 t0
  li    t0, 6
  xor   t0, t0, x0
  seqz  t0, t0
  # 减法
  sub   t1, x0, t0
  # 减法
  sub   t2, x0, t1
  # 设置返回值并返回
  mv    a0, t2
  ret
```

你需要注意的是:

* 将上述 Koopa IR 翻译到 RISC-V 汇编的方式有很多种, 你不难找到一些更简洁的翻译方式, 虽然它们实现起来可能并不那么简单.
* `x0` 是一个特殊的寄存器, 它的值恒为 0, 且向它写入的任何数据都会被丢弃.
* `t0` 到 `t6` 寄存器可以用来存放临时值.

?> 你也许会注意到, 如果按照一条指令的结果占用一个临时寄存器的目标代码生成思路, 所有的临时寄存器很快就会被用完. 本章出现的测试用例中会避免出现这种情况, 同时, 你可以自行思考: 用何种方式可以缓解这个问题. 在 Lv4 中, 我们会给出一种一劳永逸的思路来解决这个问题.
