# 前置知识

本节介绍了进行编译原理课程实践所需的部分前置知识. 如果你对此并不了解, 建议你先花一些时间进行学习.

## 如何使用 Linux

一些你需要知道的基本内容:

* **运行当前目录下程序:** `./程序名`. 比如你在当前目录下编译得到了你的编译器, 文件名为 `compiler`, 你可以执行 `./compiler`.
* **查看上一条命令的返回值:** `echo $?`. 比如你可以在 Shell 中执行 `命令; echo $?` 来运行一个命令, 同时输出它的返回值.
* **重定向输出:** 你希望把某命令输出到标准输出 (`stdout`) 的内容重定向到文件里, 可以执行 `命令 > 输出文件`. 例如: `ls > output.txt`.
* **重定向输入:** 你希望把某个文件的内容作为某个命令的输入内容 (`stdin`), 可以执行 `命令 < 输入文件`. 例如: `wc -l < input.txt`.
* **管道:** 你希望运行多个命令, 将前一个命令的标准输出作为后一个命令的标准输入, 可以执行 `命令1 | 命令2 | ... | 命令n`. 例如: `cat hello.txt | grep "hello" | wc -l`.

一些常用命令:

* `cd 目录`: 切换到目录.
* `pwd`: 输出当前目录.
* `ls`: 输出当前目录下所有的文件.
* `mkdir 目录`: 新建目录.
* `cp 源文件 目标`: 把源文件复制到目标.
* `mv 源文件 目标`: 把源文件移动到目标.
* `rm 文件`: 删除文件.
* `man 命令`: 显示命令的使用方法.

推荐 [Linux 入门教程](https://nju-projectn.github.io/ics-pa-gitbook/ics2021/linux.html).

## 如何使用 Git

Git 是一个版本控制系统 (version control system, VCS). 什么是版本控制? 为什么需要做版本控制?

想象你正在开发你的编译器, 你决定给你的编译器实现一个新的功能, 但添加这个功能需要修改大量之前的代码. 你一咬牙一狠心, 熬了个大夜, 终于把这个功能加完了, 编译时遇到的问题也都修好了. 你信心满满地打开 OJ 交了一发:

*“tmd, 一个测试用例都没过.”*

你坐在宿舍的椅子上, 窗户灌进阵阵冷风, 看着 WA 声一片的提交界面, 你的心早就凉了.

“要是能回到加这个功能之前就好了.” 你想着. 但你没有粉色大猫猫, 也没有 SERN 的 LHC (和助手), 更没有时之盾牌, 那些过去的时间再也回不去了.

不过, 不幸中的万幸, 你用 Git 管理了你的代码.

你熟练地在命令行里敲下 `git reset xxx`, 瞬间, 一切回到了那天之前.

一些你需要知道的基本内容:

* **初始化 Git 仓库:** 在仓库目录中 `git init`.
* **忽略部分文件的更改:** 在对应目录中放置 `.gitignore` 文件, 并在该文件中添加需要忽略的文件的规则.
* **查看仓库状态:** `git status`.
* **暂存更改:** `git add 文件名`, 或 `git add -A` 暂存全部更改.
* **提交更改:** `git commit`, 此时会弹出默认编辑器并要求你输入提交信息. 也可以直接执行 `git commit -m "提交信息"`.
* **添加远程仓库:** `git remote add 名称 仓库URL`.
* **推送本地提交到远程:** `git push`.
* **查看所有提交记录:** `git log`, 你可以从中看到某个提交的哈希值.
* **把仓库复位到某个提交的状态:** `git reset 提交的哈希值`.
* **从当前提交新建分支:** `git checkout -b 分支名`.
* **切换到分支:** `git checkout 分支名`.
* **删除分支:** `git branch -D 分支名`.

推荐:

* [Learn Git Branching](https://learngitbranching.js.org).
* [Git 快速入门](https://nju-projectn.github.io/ics-pa-gitbook/ics2021/git.html).

## 如何使用 GDB/LLDB

调试程序有几种方法:

* **硬看:** 基本没啥用.
* **print 大法:** 对小问题有用, 但一旦问题复杂起来, 你将迷失在巨量的日志里, 大脑过载, 难以自拔.
* **使用 IDE 提供的调试功能:** 比较有用, 但也比较复杂. 而且有些情况你没法用 IDE 的调试器解决, 比如你的编译器生成的 RISC-V 程序在 QEMU 里运行的时候出现了段错误, 你需要调试 QEMU 里的那个程序.
* **使用 GDB/LLDB 等调试器:** 非常有用, 适用范围极广, 但相对较难上手.

一些你需要知道的基本内容:

* **编译带调试信息的 C/C++ 程序:** `gcc/g++ -g -O0 ...`.
* **用调试器载入程序:** `gdb/lldb 程序名`.
* **用调试器载入程序并指定启动参数:** `gdb --args 程序名 参数 ...`, `lldb 程序名 -- 参数 ...`, 此时会进入调试器的命令行. 后续命令均需要在调试器的命令行中执行.
* **添加断点:** `b 函数名`, `b 文件名:行号`.
* **删除断点:** GDB: `d 断点编号`, LLDB: `br del 断点编号`.
* **查看所有断点:** GDB: `info b`, LLDB: `br list`.
* **执行程序:** `r`.
* **单步执行, 跳过函数:** `n`.
* **单步执行, 进入函数:** `s`.
* **继续执行直到断点/出错:** `c`.
* **查看调用栈:** `bt`.
* **切换调用栈:** GDB: `frame 编号`, LLDB: `frame select 编号`.
* **暂停执行:** `Ctrl + C`.
* **退出:** `q` 或 `Ctrl + D`.

推荐:

* [GDB cheat sheet](https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf).
* [LLDB cheat sheet](https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf).

## 为什么要设置这一节

据 MaxXing 观察, 有些同学确实完全不了解某些工具的基础使用方法. 甚至在往年的课程实践中出现过这些情况:

* 一些同学不清楚在 Linux 的 Shell 中执行当前目录下的文件时, 需要在文件名前添加 `./`.
* 一些同学不清楚为什么自己写的代码 (`xxx.c`) 无法 `#include <iostream>`.
* 一些同学不理解 `.gitignore` 文件的作用, 每次都向平台提交巨量的文件 (OJ 服务器心里苦).
* 一些同学完全不懂如何调试自己的程序, 只能每次都随便改改自己的代码, 凭运气过测试点.

考虑到大学中可能并不会专门讲授这些常识性的内容 (但显然**这不合理**), 这些现象的出现也情有可原. 但在开始实验之前, 你必须对此有一个最基本的认识, 否则在你面前的, 将会是一条通往地狱的路.

我强烈推荐大家抽一些时间, 学习一下 MIT 的 [The Missing Semester of Your CS Education](https://missing.csail.mit.edu/), 这会对你的日常开发起到相当大的帮助.
