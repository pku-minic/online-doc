# Lv5.1. 实现

本节新增/变更的语法规范如下:

```ebnf
Stmt ::= LVal "=" Exp ";"
       | [Exp] ";"
       | Block
       | "return" [Exp] ";";
```

## 一个例子

```c
int main() {
  int a = 1;
  {
    a = 2;
    int a = 3;
  }
  return a;
}
```

## 词法/语法分析

本节新增了语法规则 `[Exp] ";"`, 这代表一条仅由 `Exp` 组成的语句, 比如 `1 + 2;`. 你可能需要设计新的 AST, 同时更新你的 parser 实现.

本节的 EBNF 中出现了一种新的表示: `[ ... ]`, 这代表方括号内包含的项可被重复 0 次或 1 次. 也就是说, 单个分号 (`;`) 在 SysY 程序中也是一个合法的语句. 在 AST 中, 你可以使用空指针或 `Option` 来表示这种结构.

## 语义分析

Lv4 中, 你的编译器已经支持了一种简单的符号表: 这种符号表只支持单个作用域 (不支持作用域嵌套), 但可以检测在当前作用域内的符号重定义情况.

本节, 你只需对这个符号表稍加改动, 使其:

* **支持作用域嵌套:** 你可以把作用域的嵌套理解为, 原先只有一个符号表, 现在可以有多个, 并且它们之间存在层次关系.
* **在进入和退出代码块时更新符号表的层次结构:** 进入代码块时, 在这个结构里新建一个符号表, 这个符号表就代表当前的符号表; 退出代码块时, 删除刚刚创建的符号表, 进入代码块之前的那个符号表就代表当前的符号表.
* **只在当前作用域添加符号:** 也就是说, 只在当前层次的符号表中插入符号定义.
* **能够跨作用域查询符号定义:** 在查询符号定义时, 先在当前符号表中查询, 如果找不到就去上一层中查询. 如果在所有符号表中都没有找到这个符号的定义, 说明输入的 SysY 程序存在语义错误.

你可以选用合适的数据结构来实现这种符号表.

## IR 生成

语句块和作用域只影响了语义分析, IR 生成部分无需做任何修改.

示例程序生成的 Koopa IR 为:

```koopa
fun @main(): i32 {
%entry:
  @a_1 = alloc i32
  store 1, @a_1
  store 2, @a_1
  @a_2 = alloc i32
  store 3, @a_2
  %0 = load @a_1
  ret %0
}
```

注意:

* Koopa IR 的函数内不能定义相同的符号.
* 虽然示例程序中没有出现单个 `Exp` 表示的语句, 但在遇到这种情况时, 你必须生成 `Exp` 对应的 IR, 而不能将其跳过.

## 目标代码生成

由于 IR 生成部分未作修改, 目标代码生成部分也无需变更.

示例程序生成的 RISC-V 汇编为:

```
  .text
  .globl main
main:
  addi sp, sp, -16
  li t0, 1
  sw t0, 0(sp)
  li t0, 2
  sw t0, 0(sp)
  li t0, 3
  sw t0, 4(sp)
  lw t0, 0(sp)
  sw t0, 8(sp)
  lw a0, 8(sp)
  addi sp, sp, 16
  ret
```
