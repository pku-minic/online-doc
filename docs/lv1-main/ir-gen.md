# Lv1.4. IR 生成

上一节, 我们的编译器已经可以将只包含 `main` 函数的简单 SysY 程序解析成 AST 了——这是好的, 而且没有任何坏处, 因为我们可以在此基础上做很多事情, 比如: 生成 IR.

一旦完成了 IR 的生成, 你的编译器就已经初步成型了. 因为有一些基础设施的存在, 比如 LLVM IR, 现代的很多编译器都只会进行到 IR 生成这一步, 然后把后续的工作交给这些基础设施完成. 对于编译实践来说, 完成 IR 生成部分之后, 你就可以进行在线评测, 然后拿到编译原理课程实践部分的第一桶分 (?).

本节将讲述如何将你设计的 AST 变成编译实践中使用的 IR: Koopa IR.

## 语义分析

在生成 IR 之前, 你也许还记得我们在本章的[第一节](/lv1-main/structure)讲过编译器的结构:

* 编译器首先会对源代码做词法/语法分析, 生成 AST.
* 然后在 AST 上进行语义分析, 建立符号表, 做类型检查, 报告语义错误, 等等.
* 接着, 遍历语义分析后的 AST, 生成 IR.

我们会在每章的[开头](/lv1-main/)给出本章涉及内容的语法规范和语义规范. 一个功能完备的编译器应该能够检查输入程序是否符合语义规范, 并在发生语义错误时报错.

不过, 在课程实践中, 所有的测试用例均为符合语法/语义规范的 SysY 程序. **我们不要求你编写的编译器具备处理语法/语义错误的能力, 也不会考察这些内容.** 但我们希望学有余力的同学, 能够在自己的编译器中检查这些问题, 并对其作出合适的处理, 比如像 `clang` 或 `rustc` 一样, 给出精确到行列的错误信息, 甚至具备忽略错误继续扫描, 以及对错误给出修改建议的高级功能.

比如在本章中, 你可以在生成 IR 之前, 或生成 IR 的同时, 检查你扫描到的函数的名称是否为 `main`, 如果不是, 就向 `stderr` 输出错误信息, 并退出, 同时返回一个非零的 exit code.

## Koopa IR 基础

?> 我们建议你在完成本节的内容之前, 先阅读 [Lv0.2. Koopa IR 简介](/lv0-env-config/koopa)部分的内容.

Koopa IR 中, 最大的单位是 `Program`, 它代表一个 Koopa IR 程序. `Program` 由若干全局变量 (`Value`) 和函数 (`Function`) 构成. `Function` 又由若干基本块 (`BasicBlock`) 构成, 基本块中是一系列指令, 指令也是 `Value`. 所以 Koopa IR 程序的结构如下所示:

* `Program`
  * 全局变量列表:
    * `Value` 1.
    * `Value` 2.
    * ...
  * 函数列表:
    * `Function` 1.
      * 基本块列表:
        * `BasicBlock` 1.
          * 指令列表:
            * `Value` 1.
            * `Value` 2.
            * ...
        * `BasicBlock` 2.
        * ...
    * `Function` 2.
    * ...

上述 “全局变量”, “函数”, “指令” 的概念, 大家可能都理解, Koopa IR 中的这些概念也和编程语言中的同类概念一致. 那么, “基本块” 是什么?

基本块 ([basic block](https://en.wikipedia.org/wiki/Basic_block)) 是编译原理领域的一个很常见的概念, 它指的是一系列指令的集合, 基本块满足:

* **只有一个入口点:** 所有基本块中的指令如果要执行跳转, 只能调到某个基本块的开头, 而不能跳到中间.
* **只有一个出口点:** 基本块中, 只有最后一条指令能进行控制流的转移, 也就是跳到其他基本块, 或者从函数中返回 (执行 `return` 操作).

基本块的存在可以简化很多编译过程中需要进行的分析, 所以 Koopa IR 要求函数中的指令必须预先按照基本块分类. 同时, Koopa IR 约定, 函数的第一个基本块为函数的入口基本块, 也就是执行函数时, 首先会执行第一个基本块中的指令.

现阶段, 我们可以暂时忽略全局变量, 同时我们也可以暂时认为, `Program` 的函数列表里只有一个 `Function`, `Function` 的基本块列表里只有一个 `BasicBlock` (也就是入口基本块).

接下来, 基本块中必须存在指令, 也就是 `Value`. Koopa IR 中主要有以下几种 `Value` (详见 [`ValueKind` 的文档](https://docs.rs/koopa/latest/koopa/ir/entities/enum.ValueKind.html)):

* **各类常量:** 整数常量 (`Integer`), 零初始化器 (`ZeroInit`), 等等.
* **参数引用:** 函数参数引用 (`FuncArgRef`) 等, 用来指代传入的参数.
* **内存分配:** 全局内存分配 (`GlobalAlloc`, 所有的全局变量都是这个玩意) 和局部内存分配 (`Alloc`).
* **访存指令:** 加载 (`Load`) 和存储 (`Store`).
* **指针运算:** `GetPtr` 和 `GetElemPtr`.
* **二元运算:** `Binary`, 比如加减乘除模/比较之类的运算都属于此类.
* **控制转移:** 条件分支 (`Branch`) 和无条件跳转 (`Jump`).
* **函数相关:** 函数调用 (`Call`) 和函数返回 (`Return`).

看起来有很多很多, 但其实在本章中我们只会用到函数返回指令和整数常量, 也就是 `Return` 和 `Integer`.

所以, 现在的目标很明确了:

1. 我们应该生成一个 Koopa IR 程序.
2. 程序中有一个名字叫 `main` 的函数.
3. 函数里有一个入口基本块.
4. 基本块里有一条返回指令.
5. 返回指令的返回值就是 SysY 里 `return` 语句后跟的值, 也就是一个整数常量.

这个程序写出来长这样:

```koopa
fun @main(): i32 {  // main 函数的定义
%entry:             // 入口基本块
  ret 0             // return 0
}
```

是不是很简单? 当然, 你可能还是会有一些疑问:

* **为什么这个函数看起来叫 `@main` 而不叫 `main`?** 这是 Koopa IR 里的规定, `Function`, `BasicBlock`, `Value` 的名字必须以 `@` 或者 `%` 开头. 前者表示这是一个 “具名符号”, 后者表示这是一个 “临时符号”.
  * 这两者其实没有任何区别, 但我们通常用前者表示 SysY 里出现的符号, 用后者表示你的编译器在生成 IR 的时候生成的符号. 因为 `main` 是 SysY 里定义的, 所以这个函数叫 `@main`. 关于符号名称的细节见 [Koopa IR 规范](/misc-app-ref/koopa?id=符号名称).
* **`i32` 是什么?** Koopa IR 是一种强类型 IR, 也就是说, 诸如函数参数, 返回值, 所有指令, 它们都是有类型的.
  * `i32` 指的是 32 位有符号整数 (**32**-bit signed **i**nteger), 对应 SysY 里的 `int`. 你在编译实践前期相当长的一段时间内只会见到这一种类型.
  * Koopa IR 的分析器可以进行类型推导, 所以我们可以省略一部分类型标注. 比如你看到程序最后出现了 `ret 0`, 这个 `0` 也是有类型的. 但分析器知道 `0` 就是个整数, 它的类型是 `i32`, 所以我们不需要写 `ret i32 0`. 这点在目前看来没啥用, 但之后能帮我们简化很多复杂的表述.
* **`%entry` 是什么?** 之前解释过了, `%entry` 是这个基本块的名字. 因为基本块是你的编译器定义的, 所以它以 `%` 开头. 
  * Koopa IR 不会约束名称的定义, 这个基本块叫什么名字都行. 你懒得起名的话, 可以设置个计数器, 把基本块和 `Value` 的名字定义成 `%0`, `%1`, ... 这样的. 只不过, 起一个有意义一些的名字能方便你 debug 编译器输出的 IR.

## 生成 Koopa IR

生成 Koopa IR 非常简单: 之前我们已经介绍过怎么输出你的 AST 了, 比如给所有 AST 都实现一个 `Dump` 方法, 然后去调用 `Dump` 方法即可. 输出字符串形式的 Koopa IR 与之类似, 此处不做过多赘述.

你可能会注意到, 我们刚刚提到了 “字符串形式的 Koopa IR”, 难道 Koopa IR 除了字符串形式还有其他形式吗?

你好, 有的. Koopa IR 目前有两种形式:

1. **文本形式:** 就是你在前文见到的字符串形式, 方便人类阅读.
2. **内存形式:** 即数据结构的形式, 你可以把它理解为另一种 “AST”, 方便程序处理.

你的编译器输出的文本形式 IR, 最终会被 Koopa IR 的相关工具 (比如 `koopac`) 读取, 变成内存形式的 IR, 然后作进一步处理. Koopa IR 的框架也提供了在两种形式的 IR 之间互相转换的接口.

所以, 考虑到上述情况, 你有以下几种生成 IR 的思路:

* 遍历 AST, 输出文本形式的 IR. 这样最简单, 适用于任何语言实现的编译器.
* 调用 Koopa IR 框架提供的接口. 使用 Rust 的同学可以尝试, 详见 Koopa IR 框架的 [crates.io](https://crates.io/crates/koopa) 以及[文档](https://docs.rs/koopa).
* 像定义 AST 一样定义表示 Koopa IR 的数据结构 (比如指令/基本块/函数等等), 然后遍历 AST 输出这种结构, 再遍历这种结构输出字符串.
* 对于使用 C/C++ 的同学, 在上一条的基础上, 你可以考虑把这种结构转换成 raw program, 然后使用 `libkoopa` 中的相关接口, 将 raw program 转换成其他形式的 Koopa IR 程序.

!> 关于最后一种思路, 你可以参考 `libkoopa` 的[头文件](https://github.com/pku-minic/koopa/blob/master/crates/libkoopa/include/koopa.h), 其中定义了 raw program 的相关结构, 以及 Koopa IR 框架对 C/C++ 暴露的相关接口. 对熟悉 C/C++ 的同学来说, 这些内容应该不难理解.
<br><br>
由于文档作者 MaxXing 单枪匹马持续输出, 关于 `libkoopa` 提供的基础设施, 以及如何借助这些设施生成内存形式的 Koopa IR 程序的相关内容暂未补全. 希望他有时间可以写一下.
