# 3.2. 语义约束

符合 [3.1. 文法定义](sysy/ebnf.md)的程序集合是合法的 SysY 语言程序集合的超集. 下面, 我们进一步给出 SysY 语言的语义约束.

## 编译单元

```ebnf
CompUnit  ::= [CompUnit] (Decl | FuncDef);
Decl      ::= ConstDecl | VarDecl;
```

1. 一个 SysY 程序由单个文件组成, 文件内容对应 EBNF 表示中的 `CompUnit`. 在该 `CompUnit` 中, 必须存在且仅存在一个标识为 `main`, 无参数, 返回类型为 `int` 的 `FuncDef` (函数定义). `main` 函数是程序的入口点.
2. `CompUnit` 的顶层变量/常量声明语句 (对应 `Decl`), 函数定义 (对应 `FuncDef`) 都不可以重复定义同名标识符 (`IDENT`), 即便标识符的类型不同也不允许.
3. `CompUnit` 的变量/常量/函数声明的作用域从该声明处开始, 直到文件结尾.

## 常量定义

```ebnf
ConstDef  ::= IDENT {"[" ConstExp "]"} "=" ConstInitVal;
```

1. `ConstDef` 用于定义符号常量. `ConstDef` 中的 `IDENT` 为常量的标识符, 在 `IDENT` 后, `=` 之前是可选的数组维度和各维长度的定义部分, 在 `=` 之后是初始值.
2. `ConstDef` 的数组维度和各维长度的定义部分不存在时, 表示定义单个常量. 此时 `=` 右边必须是单个初始数值.
3. `ConstDef` 的数组维度和各维长度的定义部分存在时, 表示定义数组. 其语义和 C 语言一致, 比如 `[2][8/2][1*3]` 表示三维数组, 第一到第三维长度分别为 2, 4 和 3, 每维的下界从 0 开始编号. `ConstDef` 中表示各维长度的 `ConstExp` 都必须能在编译时被求值到非负整数. SysY 在声明数组时各维长度都需要显式给出, 而不允许是未知的.
4. 当 `ConstDef` 定义的是数组时, `=` 右边的 `ConstInitVal` 表示常量初始化器. `ConstInitVal` 中的 `ConstExp` 是能在编译时被求值的 `int` 型表达式, 其中可以引用已定义的符号常量.
5. `ConstInitVal` 初始化器必须是以下三种情况之一 (注: `int` 型初始值可以是 `Number`, 或者是 `int` 型常量表达式):
    1. 一对花括号 `{}`, 表示所有元素初始为 0.
    2. 与多维数组中数组维数和各维长度完全对应的初始值, 如 `{{1,2},{3,4},{5,6}}`, `{1,2,3,4,5,6}`, `{1,2,{3,4},5,6}` 均可作为 `a[3][2]` 的初始值.
    3. 如果花括号括起来的列表中的初始值少于数组中对应维的元素个数, 则该维其余部分将被隐式初始化, 需要被隐式初始化的整型元素均初始为 0. 如 `{{1,2},{3},{5}}`, `{1,2,{3},5}`, `{{},{3,4},5,6}` 均可作为 `a[3][2]` 的初始值, 前两个将 `a` 初始化为 `{{1,2},{3,0},{5,0}}`, `{{},{3,4},5,6}` 将 `a` 初始化为 `{{0,0},{3,4},{5,6}}`.

例如, 下列常量 `a` 到 `e` 的声明和初始化都是合法的:

```clike
const int a[4][2] = {};
const int b[4][2] = {1, 2, 3, 4, 5, 6, 7, 8};
const int c[4][2] = {{1, 2}, {3, 4}, 5, 6, 7, 8};
const int d[4][2] = {1, 2, {3}, {5}, 7 , 8};
const int e[4][2] = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
```

## 变量定义

```ebnf
VarDef  ::= IDENT {"[" ConstExp "]"}
          | IDENT {"[" ConstExp "]"} "=" InitVal;
```

1. `VarDef` 用于定义变量. 当不含有 `=` 和初始值时, 其运行时实际初值未定义.
2. `VarDef` 的数组维度和各维长度的定义部分不存在时, 表示定义单个变量; 存在时, 和 `ConstDef` 类似, 表示定义多维数组. (参见 `ConstDef` 的第 2 点)
3. 当 `VarDef` 含有 `=` 和初始值时, `=` 右边的 `InitVal` 和 `CostInitVal` 的结构要求相同, 唯一的不同是 `ConstInitVal` 中的表达式是 `ConstExp` 常量表达式, 而 `InitVal` 中的表达式可以是当前上下文合法的任何 `Exp`.
4. `VarDef` 中表示各维长度的 `ConstExp` 必须能被求值到非负整数, 但 `InitVal` 中
的初始值为 `Exp` 可以引用变量. 例如下列变量 `e` 的初始化表达式 `d[2][1]`.

```clike
int a[4][2] = {};
int b[4][2] = {1, 2, 3, 4, 5, 6, 7, 8};
int c[4][2] = {{1, 2}, {3, 4}, 5, 6, 7, 8};
int d[4][2] = {1, 2, {3}, {5}, 7 , 8};
int e[4][2] = {{d[2][1], c[2][1]}, {3, 4}, {5, 6}, {7, 8}};
```

## 初值

```ebnf
ConstInitVal  ::= ConstExp | "{" [CpnstInitVal {"," ConstInitVal}] "}";
InitVal       ::= Exp | "{" [InitVal {"," InitVal}] "}";
```

1. 全局变量声明中指定的初值表达式必须是常量表达式.
2. 未显式初始化的局部变量, 其值是不确定的; 而未显式初始化的全局变量, 其 (元素) 值均被初始化为 0.
3. 常量或变量声明中指定的初值要与该常量或变量的类型一致. 如下形式的 `VarDef`/`ConstDef` 不满足 SysY 语义约束:

```clike
a[4] = 4
a[2] = {{1,2}, 3}
a = {1,2,3}
```

## 函数形参与实参

```ebnf
FuncFParam  ::= BType IDENT ["[" "]" {"[" ConstExp "]"}];
FuncRParams ::= Exp {"," Exp};
```

1. `FuncFParam` 定义函数的一个形式参数. 当 `IDENT` 后面的可选部分存在时, 表示定义数组类型的形参.
2. 当 `FuncFParam` 为数组时, 其第一维的长度省去 (用方括号 `[]` 表示), 而后面的各维则需要用表达式指明长度, 其长度必须是常量.
3. 函数实参的语法是 `Exp`. 对于 `int` 类型的参数, 遵循按值传递的规则; 对于数组类型的参数, 形参接收的是实参数组的地址, 此后可通过地址间接访问实参数组中的元素.
4. 对于多维数组, 我们可以传递其中的一部分到形参数组中. 例如, 若存在数组定义 `int a[4][3]`, 则 `a[1]` 是包含三个元素的一维数组, `a[1]` 可以作为实参, 传递给类型为 `int[]` 的形参.

## 函数定义

```ebnf
FuncDef ::= FuncType IDENT "(" [FuncFParams] ")" Block;
```

1. `FuncDef` 表示函数定义. 其中的 `FuncType` 指明了函数的返回类型.
    * 当返回类型为 `int` 时, 函数内的所有分支都应当含有带有 `Exp` 的 `return` 语句. 不含有 `return` 语句的分支的返回值未定义.
    * 当返回值类型为 `void` 时, 函数内只能出现不带返回值的 `return` 语句.
2. `FuncDef` 中形参列表 (`FuncFParams`) 的每个形参声明 (`FuncFParam`) 用于声明 `int` 类型的参数, 或者是元素类型为 `int` 的多维数组. `FuncFParam` 的语义参见前文.

## 语句块

```ebnf
Block     ::= "{" {BlockItem} "}";
BlockItem ::= Decl | Stmt;
```

1. `Block` 表示语句块. 语句块会创建作用域, 语句块内声明的变量的生存期在该语句块内.
2. 语句块内可以再次定义与语句块外同名的变量或常量 (通过 `Decl` 语句), 其作用域从定义处开始到该语句块尾结束, 它覆盖了语句块外的同名变量或常量.

## 语句

```ebnf
Stmt  ::= LVal "=" Exp ";"
        | [Exp] ";"
        | Block
        | "if" "(" Cond ")" Stmt ["else" Stmt]
        | "while" "(" Cond ")" Stmt
        | "break" ";"
        | "continue" ";"
        | "return" [Exp] ";";
```

1. `Stmt` 中的 `if` 型语句遵循就近匹配的原则.
2. 单个 `Exp` 可以作为 `Stmt`. `Exp` 会被求值, 所求的值会被丢弃.

## 左值表达式

```ebnf
LVal  ::= IDENT {"[" Exp "]"};
```

1. `LVal` 表示具有左值的表达式, 可以为变量或者某个数组元素.
2. 当 `LVal` 表示数组时, 方括号个数必须和数组变量的维数相同 (即定位到元素).
3. 当 `LVal` 表示单个变量时, 不能出现后面的方括号.

## 表达式和条件表达式

```ebnf
Exp   ::= AddExp;
Cond  ::= LOrExp;
```

1. `Exp` 在 SysY 中代表 `int` 型表达式, 故它定义为 `AddExp`; `Cond` 代表条件表达式, 故它定义为 `LOrExp`. 前者中允许出现的单目运算符中不包括 `!`, 后者中包括.
2. `LVal` 必须是当前作用域内, 该 `Exp` 语句之前曾定义过的变量或常量. 赋值号左边的 `LVal` 必须是变量.
3. 函数调用形式是 `IDENT "(" FuncRParams ")"`, 其中的 `FuncRParams` 表示实际参数. 实际参数的类型和个数必须与 `IDENT` 对应的函数定义的形参完全匹配.
4. SysY 中算符的优先级与结合性与 C 语言一致, 上一节定义的 SysY 文法中已体现了优先级与结合性的定义.
